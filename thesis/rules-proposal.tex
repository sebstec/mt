\subsection{Rules Proposal}
\label{sec:rulesproposal}
During the evaluation of the tested firewall configuration, some firewall evading payloads were found. For some of those bypasses, new rule configurations will be proposed. As mentioned before, adding new filtering rules always poses a risk that subsequently, benign requests might be flagged as malicious. As such, the possible implications of adding new firewall rules needs to be considered.

	{\color{red} TODO: explain modsecurity/coreruleset rule setup?}

\subsubsection{Function Constructor}
\label{sec:rulespropfunctionconstructor}
The bypassing payload from sections Section~\ref{sec:funconstrconbypass}: Function Constructor + String Concatenation, Section~\ref{sec:avoidingbypassA}: Avoiding () and Section~\ref{sec:avoidingbypassB}: Avoiding \{\} rely on accessing the function constructor by accessing functions on built-in objects.

To block requests using the function contructor (dot notation) as a method to evade the current evaluated firewall configuration, a new firewall rule (Listing~\ref{lst:constuctorsruleproposal}) is proposed:

\begin{lstlisting}[style=basicStyle, caption=rule proposal to block usage of function constructor via dot notation, label={lst:constructorsruleproposal}]
SecRule REQUEST_COOKIES|REQUEST_COOKIES_NAMES|ARGS_NAMES|ARGS|XML:/* "@rx (?i)(?:(?:\[[^\]]*\])|(?:\{[^}]*\}))\.[a-z]*\.constructor[`,(,\[]" \
    "id:2,\
    phase:2,\
    auditlog,\
    capture,\
    t:none,t:urlDecodeUni,t:compressWhitespace,\
    msg:'XSS JavaScript function with constructor',\
    logdata:'Matched Data: %{TX.0} found within %{MATCHED_VAR_NAME}: %{MATCHED_VAR}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'attack-xss',\
    tag:'xss-perf-disable',\
    tag:'paranoia-level/1',\
    severity:'CRITICAL',\
    setvar:'tx.xss_score=+%{tx.critical_anomaly_score}',\
    setvar:'tx.inbound_anomaly_score_pl1=+%{tx.critical_anomaly_score}'"
\end{lstlisting}

The rule with \verb|id:2| shown in Listing~\ref{lst:constructorsruleproposal} aims at matching usage of the function constructor via dot notation using the following (Listing~\ref{lst:constructorsruleproposalregex}) regular expression:

\begin{lstlisting}[style=basicStyle, caption=regex of proposed rule id:2, label={lst:constructorsruleproposalregex}]
(?i)(?:(?:\[[^\]]*\])|(?:\{[^}]*\}))\.[a-z]*\.constructor[`,(,\[]

explanation:
(?i)  match the remainder of the pattern with the i modifier: Case insensitive match

(?:   start a non-capturing group (object group)

(?:   start a non-capturing group (square bracket group)
\[    match on a single opening square bracket
[     start a list
^\]   exclude the closing square bracket from matching
]     end the list
*     match the characters from the list (anything that is not a square closing bracket) between 0 and unlimited times
\]    match on a single closing square bracket
)     close the group (square bracket group)

|     give an alternative the previous group (square bracket group)

(?:	  start a non-capturing group (curly bracket group)
\{	  match on a single opening curly bracket
[     start a list
^}	  exclude the closing curly bracket
]     end the list
*     match the characters from the list (anything that is not a curly closing bracket) between 0 and unlimited times
\}	  match on a single closing curly bracket
)     close the group (curly bracket group)

)     close the group (object group)

\.    match on a single dot

[     start a list
a-z   match a single character between a (index 97) and z (index 122)
]     end the list
*     match the characters from the list (anything from a to z) between 0 and unlimited times

\.	  match on a single dot

constructor    match on the word "constructor"

[     start a list
`,(,\[         match on a single `, opening round bracket or opening square bracket
]     end the list
\end{lstlisting}

The two payload options of: \\
\verb|[].something.constructor()| and \verb|{}.something.constructor()| \\
are matched by this regular expression. Therefore, once the configuration is updated with the proposed rule, the bypassing payload using dot notation that has been discovered in Section~\ref{sec:funconstrconbypass} is being detected by the evaluated firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=function constructor bypass payload using dot notation blocked, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor('var s = "secret";promp' + 't("something", s)')()</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor("</MatchedData>
\end{lstlisting}

Equally, the bypassing payloads using dot notation that have been discovered in Section~\ref{sec:avoidingbypassA} and  Section~\ref{sec:avoidingbypassB} are now being detected by the evaluated firewall. Section~\ref{sec:avoidingbypassA}: Avoiding () bypass:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=avoiding () bypass payload using dot notation blocked, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor`"</MatchedData>
\end{lstlisting}

Section~\ref{sec:avoidingbypassB}: Avoiding {} bypass:

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using dot notation, label={lst:stringreplacepass}]
\end{lstlisting}
\begin{lstlisting}[style=ruleStyle, language=XML, caption=using constructors rule poc, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor("</MatchedData>
\end{lstlisting}

The proposed firewall rule manages to block a part the mentioned bypassing payloads. The sections Section~\ref{sec:funconstrconbypass}, Section~\ref{sec:avoidingbypassA} and Section~\ref{sec:avoidingbypassB} further state similar payloads created using the square bracket notation. These are not detected and filtered by the proposed rule with id:2.

To block requests using the function contructor via square bracket notation, another firewall rule (id:3) is proposed:

\begin{lstlisting}[style=basicStyle, caption=rule proposal to block usage of function constructor via square bracket notation, label={lst:constructorsruleproposalB}]
SecRule REQUEST_COOKIES|REQUEST_COOKIES_NAMES|ARGS_NAMES|ARGS|XML:/* "@rx (?i)(?:(?:\[[^\]]*\])|(?:\{[^}]*\}))\.[a-z]*\.constructor[`,(,\[]" \
    "id:2,\
    phase:2,\
    auditlog,\
    capture,\
    t:none,t:urlDecodeUni,t:compressWhitespace,\
    msg:'XSS JavaScript function with constructor',\
    logdata:'Matched Data: %{TX.0} found within %{MATCHED_VAR_NAME}: %{MATCHED_VAR}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'attack-xss',\
    tag:'xss-perf-disable',\
    tag:'paranoia-level/1',\
    severity:'CRITICAL',\
    setvar:'tx.xss_score=+%{tx.critical_anomaly_score}',\
    setvar:'tx.inbound_anomaly_score_pl1=+%{tx.critical_anomaly_score}'"
\end{lstlisting}

The rule with \verb|id:2| shown in Listing~\ref{lst:constructorsruleproposal} aims at matching usage of the function constructor via dot notation using the following (Listing~\ref{lst:constructorsruleproposalregex}) regular expression:

\begin{lstlisting}[style=basicStyle, caption=regex of proposed rule id:2, label={lst:constructorsruleproposalregex}]
(?i)(?:(?:\[[^\]]*\])|(?:\{[^}]*\}))\[[`,',"][a-z]*[`,',"]\]\[[`,',"]constructor[`,',"]\][`,(,\[]

explanation:
(?i)  match the remainder of the pattern with the i modifier: Case insensitive match

(?:   start a non-capturing group (object group)

(?:   start a non-capturing group (square bracket group)
\[    match on a single opening square bracket
[     start a list
^\]   exclude the closing square bracket from matching
]     end the list
*     match the characters from the list (anything that is not a square closing bracket) between 0 and unlimited times
\]    match on a single closing square bracket
)     close the group (square bracket group)

|     give an alternative the previous group (square bracket group)

(?:	  start a non-capturing group (curly bracket group)
\{	  match on a single opening curly bracket
[     start a list
^}	  exclude the closing curly bracket
]     end the list
*     match the characters from the list (anything that is not a curly closing bracket) between 0 and unlimited times
\}	  match on a single closing curly bracket
)     close the group (curly bracket group)

)     close the group (object group)

\.    match on a single dot

[     start a list
a-z   match a single character between a (index 97) and z (index 122)
]     end the list
*     match the characters from the list (anything from a to z) between 0 and unlimited times

\.	  match on a single dot

constructor    match on the word "constructor"

[     start a list
`,(,\[         match on a single `, opening round bracket or opening square bracket
]     end the list
\end{lstlisting}

The two payload options of: \\
\verb|[].something.constructor()| and \verb|{}.something.constructor()| \\
are matched by this regular expression. Therefore, once the configuration is updated with the proposed rule, the bypassing payload using dot notation that has been discovered in Section~\ref{sec:funconstrconbypass} is being detected by the evaluated firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=function constructor bypass payload using dot notation blocked, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor('var s = "secret";promp' + 't("something", s)')()</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor("</MatchedData>
\end{lstlisting}

Equally, the bypassing payloads using dot notation that have been discovered in Section~\ref{sec:avoidingbypassA} and  Section~\ref{sec:avoidingbypassB} are now being detected by the evaluated firewall. Section~\ref{sec:avoidingbypassA}: Avoiding () bypass:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=avoiding () bypass payload using dot notation blocked, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor`"</MatchedData>
\end{lstlisting}

Section~\ref{sec:avoidingbypassB}: Avoiding {} bypass:

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using dot notation, label={lst:stringreplacepass}]
\end{lstlisting}
\begin{lstlisting}[style=ruleStyle, language=XML, caption=using constructors rule poc, label={lst:constructorsblockedpoc}]
<payload>[].constructor.constructor('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();</payload>
<message>"XSS JavaScript function with constructor"</message>
<file>"/rules/REQUEST-000-XSS-PROPOSAL.conf"</file>
<fileDetails>[line "13"] [id "2"]<fileDetails>
<MatchedData>"[].constructor.constructor("</MatchedData>
\end{lstlisting}

The proposed firewall rule manages to block a part the mentioned bypassing payloads. The sections Section~\ref{sec:funconstrconbypass}, Section~\ref{sec:avoidingbypassA} and Section~\ref{sec:avoidingbypassB} further state similar payloads created using the square bracket notation. These are not detected and filtered by the proposed rule with id:2.





While accessing the function constructor as it is done in the mentioned bypassing payloads is no longer possible with the proposed rule, the idea behind accessing the function constructor by accessing the constructor of JavaScripts built-in objects should be further investigated. Without further investigation, there is no way to know if accessing the constructor is only possible on created objects if they are created by calling \verb|{}| or \verb|[]|. Simply using the \verb|new Object()| or \verb|new Array()| syntax is also valid and needs to be covered by firewall rules.

	{\color{blue}kurzes test bei weitere investigation hat ergeben das geht auch: Proxy.constructor.constructor('al' + 'ert("Proxy")')(); }


	{\color{red}Ideen bisher:}

Unicode Normalization: ModSec WAF uses transformers to decode URL encoded payloads before they are checked against the ruleset, they same could be done with unicode normalization. normalize according to NFKC and then check the request against the ruleset

Regex to detect and block \verb|["something(any array or object function)"]["constructor"]|

Regex to detect and block \verb|["something(any array or object function)"].constructor|






{\color{red} TODO: mehr in form von: Considering evaluation result [ref], it a rule in the form of [listing] could potentially avoid a bypass using the technique [ref]}
