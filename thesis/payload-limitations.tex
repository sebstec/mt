\subsection{Payload limitations}
\label{sec:payloadlimitations}
{\color{blue} evtl das hier raus? falls nicht mehr viel mehr dazu gefunden wird}
On usage of Tagged Template Literals, the function always get called with the first parameter being an array, the second parameter being the first placeholder expression. (see Section~\ref{sec:taggedtemplateliterals}) Therefore, a workaround must be found if the return value of an expression is to be displayed. For instance, substituting \verb|alert| with \verb|prompt| in combination with Tagged Template Literals allows to display a parameter given to the template string. Using \verb|alert| will limit the displaying possibilities to the first parameter (an array of strings) of a Tagged Template Literal call. The function \verb|prompt| allows two parameters whereas the second parameter is used for a default input text in the displayed prompt. \cite{js/prompt} Therefore its possible to display the expression in the first placeholder \verb|${expression}| after string coercion. {\color{red} todo: according to this example, sometimes workaround in the form of payloads with a similar logic are neccessary}

It seems to be more versatile to use the function constructor or eval in some form to be able to use string operations on the payload. {\color{red} TODO: explain and conclude -> successful blocking of eval + function constructor by waf will limit injection possibilities}

{}[].constructor.constructor('alert' + '(`concatenation`)')(): de

